# canlogger

#Specification:
Develop C++ application for mining loader's on-board computer.
On-board computer is ARM-based embedded PC running Linux, it have WLAN adapter and CAN connection to loader's ECU.

Signals are engine and hydraulics measurements:
Engine RPM
Engine Coolant temperature
Engine Oil Temperature
Engine Oil Pressure
Hydraulic Oil Temperature
Hydraulic Oil Pressure
Data is production measurements:
Scoop bucket load weight
Bucket dump timestamp

Signals and data should be collected by application and stored in SQLite database.
Trigger for data upload is configured minimal size of data packet and WLAN availability.
Data is transmitted over UDP socket to logging server from which it is sent over https to cloud-based backend application.

ECU mock will be sending randomly changing values with configured period over vcan interface.
Production data is generated by mock of bucket scales - it will send weight of unloaded rock at random intervals over CAN.

vcan setup:
sudo modprobe vcan
sudo ip link add dev vcan0 type vcan
sudo ifconfig vcan0 up

can_logger application is mocking on-board computer app, it uses sqlite in-memory database for signals buffering
install sqlite:
sudo apt-get install libsqlite3-dev

build can_logger:
g++ -o can_logger can_logger.cpp -lsqlite3

build mocks:
g++ -o ecu_mock ecu_mock.cpp
g++ -o scales_mock scales_mock.cpp

run:
in one terminal - ./ecu_mock
in another terminal - ./scales_mock
in yet another terminal - ./can_logger

can_logger will print received measurements and "Sending data.." every 100 measurements. No real sending yet.
